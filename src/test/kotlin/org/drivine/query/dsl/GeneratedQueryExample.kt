package org.drivine.query.dsl

import sample.mapped.fragment.Issue
import sample.mapped.fragment.Person
import sample.mapped.view.PersonContext
import sample.mapped.view.RaisedAndAssignedIssue
import java.util.*

/**
 * Example of what code generation would produce for RaisedAndAssignedIssue.
 *
 * This is hand-written to demonstrate the structure, but would be
 * auto-generated by an annotation processor in the future.
 *
 * Generation would happen at compile time by:
 * 1. Scanning for @GraphView and @GraphFragment classes
 * 2. Reading the GraphViewModel/FragmentModel metadata
 * 3. Generating property reference objects based on field types
 */

// Generated for the GraphView
object RaisedAndAssignedIssueQuery {
    /**
     * Properties of the root fragment (Issue)
     */
    val issue = IssueProperties("issue")

    /**
     * Properties of the assignedTo relationship targets (List<Person>)
     * The alias matches the relationship field name from the GraphView
     */
    val assignedTo = PersonProperties("assignedTo")

    /**
     * Properties of the raisedBy relationship target (PersonContext)
     */
    val raisedBy = PersonContextProperties("raisedBy")
}

/**
 * Generated for the Issue fragment.
 * Each property gets a typed PropertyReference based on its Kotlin type.
 */
class IssueProperties(private val alias: String) {
    val uuid = PropertyReference<UUID>(alias, "uuid")
    val id = PropertyReference<Long>(alias, "id")
    val state = StringPropertyReference(alias, "state")  // String gets StringPropertyReference for CONTAINS, etc
    val stateReason = StringPropertyReference(alias, "stateReason")  // nullable, but PropertyReference handles it
    val title = StringPropertyReference(alias, "title")
    val body = StringPropertyReference(alias, "body")
    val locked = PropertyReference<Boolean>(alias, "locked")
}

/**
 * Generated for the Person fragment.
 */
class PersonProperties(private val alias: String) {
    val uuid = PropertyReference<UUID>(alias, "uuid")
    val name = StringPropertyReference(alias, "name")
    val bio = StringPropertyReference(alias, "bio")
}

/**
 * Generated for the PersonContext view.
 * Note: This would recursively generate property references for nested views too!
 */
class PersonContextProperties(private val alias: String) {
    // PersonContext has a 'person' root fragment
    val person = PersonProperties(alias)  // Reuse PersonProperties

    // PersonContext has a 'worksFor' relationship to Organization
    // val worksFor = OrganizationProperties("${alias}_worksFor")
}

/**
 * Code generation strategy:
 *
 * 1. For each @GraphView:
 *    - Generate a Query object (e.g., RaisedAndAssignedIssueQuery)
 *    - Add property for root fragment using its field name as alias
 *    - Add properties for each relationship using field name as alias
 *
 * 2. For each @GraphFragment:
 *    - Generate a Properties class (e.g., IssueProperties)
 *    - For each field:
 *      - String -> StringPropertyReference
 *      - Other types -> PropertyReference<T>
 *      - Skip @GraphNodeId if user doesn't want to filter on it
 *
 * 3. For nested GraphViews in relationships:
 *    - Recursively generate Properties classes
 *    - Use composite aliases for nested relationships
 *
 * 4. Naming conventions:
 *    - GraphView "Foo" -> "FooQuery" object
 *    - GraphFragment "Bar" -> "BarProperties" class
 *    - All generated code in same package as source or in .generated subpackage
 */

/**
 * Usage example:
 */
fun usageExample() {
    val queryObject = RaisedAndAssignedIssueQuery
    val spec = GraphQuerySpec(queryObject)

    spec.where {
        // Root fragment properties
        this(query.issue.state eq "open")
        this(query.issue.id gt 1000)
        this(query.issue.title.startsWith("Implement"))

        // Relationship target properties
        this(query.assignedTo.name eq "Kent Beck")
        this(query.raisedBy.person.bio.contains("Spring"))
    }

    spec.orderBy {
        this(query.issue.id.desc())
    }
}

/**
 * Integration with annotation processor:
 *
 * The code generator would be a separate module that:
 * 1. Depends on: drivine-core (for annotations), KSP or KAPT (for processing)
 * 2. Processes: @GraphView and @GraphFragment annotations
 * 3. Generates: Query objects and Properties classes
 * 4. Output: Generated .kt files in build/generated/source/
 *
 * Users would add to their build.gradle:
 * ```kotlin
 * plugins {
 *     id("com.google.devtools.ksp") version "..."
 * }
 *
 * dependencies {
 *     implementation("org.drivine:drivine-core:...")
 *     ksp("org.drivine:drivine-codegen:...")  // The annotation processor
 * }
 * ```
 */